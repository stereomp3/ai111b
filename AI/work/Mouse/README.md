老鼠走迷宮問題，就是一個可以採用圖形搜尋來解決的經典問題，其中每個節點的鄰居，就是上下左右四個方向，只要沒有被牆給擋住，就可以走到鄰居節點去

[code](mouse.py)

```
00000000
00.0.000
M....000
0.000000
0.....00
00000.00
迷宮使用二維陣列表示
     [['0', '0', '0', '0', '0', '0', '0', '0'],
     ['0', '0', '.', '0', '.', '0', '0', '0'],
     ['M', '.', '.', '.', '.', '0', '0', '0'],
     ['0', '.', '0', '0', '0', '0', '0', '0'],
     ['0', '.', '.', '.', '.', '.', '0', '0'],
     ['0', '0', '0', '0', '0', '.', '0', '0'], ]
     設 . 為路
     設 0 為牆
     設 M 為出發點
     x 從上往下
     y 從左往右
```



使用BFS找最短路徑，如果沒有找到路，那就回傳: `No Way to go out.`



```python
import queue


m = [['0', '0', '0', '0', '0', '0', '0', '0'],
     ['0', '0', '.', '0', '.', '0', '0', '0'],
     ['M', '.', '.', '.', '.', '0', '0', '0'],
     ['0', '.', '0', '0', '0', '0', '0', '0'],
     ['0', '.', '.', '.', '.', '.', '0', '0'],
     ['0', '0', '0', '0', '0', '.', '0', '0'], ]

Mx = 0
My = 0
col = len(m[0])
row = len(m)
for x in range(row):
    for y in range(col):
        if m[x][y] == "M":
            Mx = x
            My = y
print(Mx)
print(My)

q = queue.Queue()
q.put((Mx, My, 0))  # x,y,step

# build m，使用BFS建立路徑表格，填入所有路徑，路只會建立一次，只有偵測到.才會把pos放入到queue
while not q.empty():
    pos = q.get()  # pos[0] = x, pos[1] = y
    print(pos)
    if pos[0] + 1 < row:  # down
        if m[pos[0] + 1][pos[1]] == '.':  # is road
            q.put((pos[0] + 1, pos[1], pos[2] + 1))
            m[pos[0] + 1][pos[1]] = pos[2] + 1

    if pos[0] - 1 >= 0:  # up
        if m[pos[0] - 1][pos[1]] == '.':
            q.put((pos[0] - 1, pos[1], pos[2] + 1))
            m[pos[0] - 1][pos[1]] = pos[2] + 1
    if pos[1] + 1 < col:  # right
        if m[pos[0]][pos[1] + 1] == '.':
            q.put((pos[0], pos[1] + 1, pos[2] + 1))
            m[pos[0]][pos[1] + 1] = pos[2] + 1
    if pos[1] - 1 >= 0:  # left
        if m[pos[0]][pos[1] - 1] == '.':
            q.put((pos[0], pos[1] - 1, pos[2] + 1))
            m[pos[0]][pos[1] - 1] = pos[2] + 1


shortest = -1
# 沿著外圈找，如果是數字(非0、.、M)，那就代表找到出口，數字越小，代表找到的出口路徑越短
for x in range(row):
    for y in range(col):
        if x == 0 or x == row-1 or y == 0 or y == col-1:  # check board
            if m[x][y] != "0" and m[x][y] != "." and m[x][y] != "M": 
                if shortest > int(m[x][y]) or shortest == -1:  # check if the shortest
                    shortest = int(m[x][y])
if shortest == -1:
    print("No Way to go out.")
else:
    print(shortest)

```





如果輸入是

```
00000000
00.0.000
M....000
0.000000
0.....00
00000.00
```

輸出就會是`8`

最後的m會是，可以看到，外圍有非0、.、M的數字，所以就是8

```
00000000
00305000
M1234000
02000000
03456700
00000800
```





輸入是

```
00000000
00.0.000
M....000
0.000000
0.....00
00000000
```

輸出就就會是`No Way to go out.`

最後的m會是，因為外圈全是0，所以最後會找不到出口

```
00000000
00305000
M1234000
02000000
03456700
00000000
```

